<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>Skanner QR / EAN / DataMatrix</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- LOKALNIE, nie z CDN -->
  <script src="./html5-qrcode.min.js"></script>

  <style>
    body { font-family: Arial, sans-serif; margin: 10px; }
    #reader { width: 100%; max-width: 420px; margin: 10px auto; }
    button, select, input[type="range"] { margin: 5px 3px; padding: 8px 12px; cursor: pointer; }
    button:disabled, select:disabled, input:disabled { opacity: 0.5; cursor: not-allowed; }
    #codes-list { margin-top: 15px; padding-left: 20px; }
    #codes-list li { word-break: break-all; margin-bottom: 3px; font-size: 14px; }
    #status { margin-top: 8px; font-size: 14px; }
    #reset-btn { background-color: #ff4d4d; color: #fff; }
    #torch-btn { background-color: #222; color: #fff; }
    .row { display: flex; flex-wrap: wrap; align-items: center; gap: 6px; }
    .hint { font-size: 12px; opacity: 0.8; margin-top: 6px; }
    label { font-size: 12px; opacity: 0.85; margin-right: 6px; }
    #zoom-wrap { display: none; align-items: center; gap: 8px; }
    #zoom-val { font-size: 12px; opacity: 0.85; min-width: 46px; text-align: right; }
    code { background: #f3f3f3; padding: 1px 4px; border-radius: 4px; }
  </style>
</head>

<body>
  <h2>Skanner QR / EAN / DataMatrix</h2>

  <div class="row">
    <button id="start-btn">Start</button>
    <button id="stop-btn" disabled>Stop</button>
    <button id="torch-btn" disabled>Latarka: OFF</button>
    <button id="clear-btn">Wyczyść</button>
    <button id="reset-btn">Reset</button>
  </div>

  <div id="status">Status: nie skanuje</div>
  <div class="hint">
    Kamera działa tylko w <b>HTTPS</b> lub <b>http://localhost</b>.
    Dla 1D (EAN/UPC) trzymaj telefon trochę dalej i złap cały kod w ramkę.
  </div>

  <div class="row" style="margin-top:8px;">
    <label for="mode-select">Tryb:</label>
    <select id="mode-select">
      <option value="auto" selected>AUTO (QR + DataMatrix + 1D)</option>
      <option value="2d">2D (QR + DataMatrix)</option>
      <option value="1d">1D (EAN/UPC/Code128...)</option>
    </select>

    <label for="camera-select">Kamera:</label>
    <select id="camera-select" disabled>
      <option>(Kliknij Start)</option>
    </select>

    <div id="zoom-wrap" class="row">
      <label for="zoom-range">Zoom:</label>
      <input id="zoom-range" type="range" min="1" max="1" step="0.1" value="1" />
      <div id="zoom-val">1.0×</div>
    </div>
  </div>

  <div id="reader"></div>

  <h3>Zeskanowane kody:</h3>
  <ul id="codes-list"></ul>

  <div class="row">
    <button id="download-txt-btn">Pobierz TXT</button>
    <button id="download-csv-btn">Pobierz CSV</button>
  </div>

  <script>
    const STORAGE_KEY = "scanned_codes_v10";
    const CAM_KEY = "camera_deviceId_v3";

    const scannedCodes = new Set();

    const elList = document.getElementById("codes-list");
    const startBtn = document.getElementById("start-btn");
    const stopBtn = document.getElementById("stop-btn");
    const clearBtn = document.getElementById("clear-btn");
    const resetBtn = document.getElementById("reset-btn");
    const txtBtn = document.getElementById("download-txt-btn");
    const csvBtn = document.getElementById("download-csv-btn");
    const statusEl = document.getElementById("status");
    const torchBtn = document.getElementById("torch-btn");

    const camSelect = document.getElementById("camera-select");
    const modeSelect = document.getElementById("mode-select");

    const zoomWrap = document.getElementById("zoom-wrap");
    const zoomRange = document.getElementById("zoom-range");
    const zoomVal = document.getElementById("zoom-val");

    let scanning = false;
    let torchOn = false;
    let hasTorch = false;
    let zoomCaps = null;
    let qr = null;

    function setStatus(t) { statusEl.textContent = "Status: " + t; }

    function setButtons(isScanning) {
      scanning = isScanning;
      startBtn.disabled = isScanning;
      stopBtn.disabled = !isScanning;
      torchBtn.disabled = !isScanning || !hasTorch;
      camSelect.disabled = !isScanning;
      modeSelect.disabled = isScanning; // zmiana trybu = restart (robimy przy Stop/Start)
    }

    function renderList() {
      elList.innerHTML = "";
      for (const code of scannedCodes) {
        const li = document.createElement("li");
        li.textContent = code;
        elList.appendChild(li);
      }
    }

    function save() { localStorage.setItem(STORAGE_KEY, JSON.stringify([...scannedCodes])); }

    function load() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const arr = JSON.parse(raw);
        if (Array.isArray(arr)) arr.forEach(x => scannedCodes.add(x));
      } catch {}
    }

    function downloadFile(content, name, type) {
      const blob = new Blob([content], { type });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = name;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function downloadTxt() {
      if (!scannedCodes.size) return alert("Brak kodów.");
      downloadFile([...scannedCodes].join("\n"), "kody.txt", "text/plain;charset=utf-8");
    }

    function downloadCsv() {
      if (!scannedCodes.size) return alert("Brak kodów.");
      const rows = ["Nr;Kod"];
      [...scannedCodes].forEach((code, i) => {
        const safe = '"' + String(code).replace(/"/g, '""') + '"';
        rows.push(`${i+1};${safe}`);
      });
      const bom = "\uFEFF";
      downloadFile(bom + rows.join("\n"), "kody.csv", "text/csv;charset=utf-8");
    }

    function clearAll() {
      if (!scannedCodes.size) return;
      if (!confirm("Usunąć wszystkie kody?")) return;
      scannedCodes.clear();
      save();
      renderList();
      setStatus("wyczyszczono");
    }

    function onScanSuccess(decodedText /*, decodedResult */) {
      const entry = String(decodedText).trim();
      if (!entry) return;

      if (!scannedCodes.has(entry)) {
        scannedCodes.add(entry);
        save();
        renderList();
      }
    }

    function showErr(e) {
      const name = e?.name || "UnknownError";
      const msg  = e?.message || String(e);
      console.error(e);
      alert(`${name}\n${msg}`);
      setStatus(`błąd: ${name}`);
    }

    async function ensureCameraPermission() {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
      stream.getTracks().forEach(t => t.stop());
    }

    async function populateCameras() {
      camSelect.innerHTML = "";
      let devices = [];

      // 1) Preferowane
      try { devices = await Html5Qrcode.getCameras(); } catch {}

      // 2) Fallback
      if (!devices || !devices.length) {
        try {
          const all = await navigator.mediaDevices.enumerateDevices();
          devices = all
            .filter(d => d.kind === "videoinput")
            .map((d, i) => ({ id: d.deviceId, label: d.label || `Kamera ${i + 1}` }));
        } catch {}
      }

      if (!devices.length) {
        camSelect.disabled = true;
        camSelect.innerHTML = `<option>(Brak listy kamer)</option>`;
        return false;
      }

      devices.forEach((d, idx) => {
        const opt = document.createElement("option");
        opt.value = d.id;
        opt.textContent = d.label || `Kamera ${idx + 1}`;
        camSelect.appendChild(opt);
      });

      const saved = localStorage.getItem(CAM_KEY);
      if (saved && devices.some(d => d.id === saved)) camSelect.value = saved;
      else camSelect.value = devices[0].id;

      camSelect.disabled = false;
      return true;
    }

    function getFormatsForMode(mode) {
      const F = Html5QrcodeSupportedFormats;

      const formats2D = [ F.QR_CODE, F.DATA_MATRIX ];
      const formats1D = [
        F.EAN_13, F.EAN_8, F.UPC_A, F.UPC_E,
        F.CODE_128, F.CODE_39, F.ITF
      ];

      if (mode === "2d") return formats2D;
      if (mode === "1d") return formats1D;
      return [...formats2D, ...formats1D]; // auto
    }

    function getQrboxForMode(mode) {
      // 2D: kwadrat; 1D: prostokąt poziomy; auto: kompromis (trochę szerszy)
      if (mode === "2d") return { width: 320, height: 320 };
      if (mode === "1d") return { width: 380, height: 220 };
      return { width: 360, height: 260 };
    }

    async function applyAutofocusQuality(qrInstance) {
      try {
        await qrInstance.applyVideoConstraints({
          width: { ideal: 1280 },
          height: { ideal: 720 },
          advanced: [{ focusMode: "continuous" }]
        });
      } catch {}
    }

    async function detectTorchAndZoom(qrInstance) {
      hasTorch = false;
      zoomCaps = null;
      zoomWrap.style.display = "none";
      torchBtn.textContent = "Latarka: OFF";
      torchOn = false;

      try {
        const track = qrInstance.getRunningTrack?.();
        const caps = track?.getCapabilities?.() || {};

        if ("torch" in caps) hasTorch = true;

        if (caps.zoom) {
          const min = caps.zoom.min ?? 1;
          const max = caps.zoom.max ?? 1;
          const step = caps.zoom.step ?? 0.1;
          zoomCaps = { min, max, step };

          zoomRange.min = String(min);
          zoomRange.max = String(max);
          zoomRange.step = String(step);
          zoomRange.value = String(min);
          zoomVal.textContent = `${Number(min).toFixed(1)}×`;
          zoomWrap.style.display = "flex";

          // delikatny zoom na start
          const target = Math.min(max, min + (max - min) * 0.25);
          try {
            await qrInstance.applyVideoConstraints({ advanced: [{ zoom: target }] });
            zoomRange.value = String(target);
            zoomVal.textContent = `${Number(target).toFixed(1)}×`;
          } catch {}
        }
      } catch {}

      torchBtn.disabled = !scanning || !hasTorch;
    }

    async function setTorch(qrInstance, on) {
      try {
        await qrInstance.applyVideoConstraints({ advanced: [{ torch: !!on }] });
        torchOn = !!on;
        torchBtn.textContent = `Latarka: ${torchOn ? "ON" : "OFF"}`;
      } catch {
        hasTorch = false;
        torchOn = false;
        torchBtn.disabled = true;
        torchBtn.textContent = "Latarka: brak";
      }
    }

    async function setZoom(qrInstance, value) {
      try {
        await qrInstance.applyVideoConstraints({ advanced: [{ zoom: Number(value) }] });
      } catch {}
    }

    async function startWithDeviceId(deviceId) {
      if (!qr) qr = new Html5Qrcode("reader");

      const mode = modeSelect.value;
      const formatsToSupport = getFormatsForMode(mode);
      const qrbox = getQrboxForMode(mode);

      const config = {
        fps: 15,
        qrbox,
        disableFlip: true,
        formatsToSupport
      };

      const cameraConfig = deviceId
        ? { deviceId: { exact: deviceId } }
        : { facingMode: "environment" };

      await qr.start(cameraConfig, config, onScanSuccess, () => {});
    }

    async function startScanning() {
      if (scanning) return;

      if (!window.isSecureContext) {
        alert("Brak HTTPS/localhost. Kamera nie ruszy.");
        setStatus("brak HTTPS/localhost");
        return;
      }
      if (typeof Html5Qrcode === "undefined") {
        alert("Brakuje pliku ./html5-qrcode.min.js obok index.html");
        return;
      }

      try {
        setStatus("proszę o dostęp do kamery...");
        await ensureCameraPermission();

        const ok = await populateCameras();
        if (!ok) {
          setStatus("brak listy kamer");
          alert("Nie udało się pobrać listy kamer. Spróbuj w Chrome/Safari (nie w FB/IG/Messenger).");
          return;
        }

        await startWithDeviceId(camSelect.value);

        setButtons(true);
        setStatus(`skanuje (${modeSelect.options[modeSelect.selectedIndex].text})`);

        await applyAutofocusQuality(qr);
        await detectTorchAndZoom(qr);

      } catch (e) {
        setButtons(false);
        showErr(e);
      }
    }

    async function stopScanning(updateUi = true) {
      if (!qr) return;
      try {
        if (torchOn) { try { await setTorch(qr, false); } catch {} }
        await qr.stop();
      } catch (e) {
        console.warn(e);
      } finally {
        torchOn = false;
        hasTorch = false;
        zoomCaps = null;
        zoomWrap.style.display = "none";
        if (updateUi) {
          torchBtn.textContent = "Latarka: OFF";
          setButtons(false);
          setStatus("zatrzymano");
        }
      }
    }

    async function resetScanner() {
      if (!confirm("Zresetować i usunąć wszystkie kody?")) return;
      if (scanning) await stopScanning(true);
      scannedCodes.clear();
      localStorage.removeItem(STORAGE_KEY);
      renderList();
      setStatus("zresetowano");
    }

    // Zmiana kamery -> restart skanowania na nowej
    camSelect.addEventListener("change", async () => {
      const id = camSelect.value;
      if (id) localStorage.setItem(CAM_KEY, id);
      if (!scanning) return;

      try {
        setStatus("przełączam kamerę...");
        await stopScanning(false);
        await startWithDeviceId(id);
        setButtons(true);
        setStatus(`skanuje (${modeSelect.options[modeSelect.selectedIndex].text})`);
        await applyAutofocusQuality(qr);
        await detectTorchAndZoom(qr);
      } catch (e) {
        showErr(e);
        setStatus("błąd przełączania");
      }
    });

    zoomRange.addEventListener("input", async () => {
      zoomVal.textContent = `${Number(zoomRange.value).toFixed(1)}×`;
      if (scanning && qr && zoomCaps) await setZoom(qr, zoomRange.value);
    });

    startBtn.addEventListener("click", startScanning);
    stopBtn.addEventListener("click", () => stopScanning(true));
    clearBtn.addEventListener("click", clearAll);
    resetBtn.addEventListener("click", resetScanner);
    txtBtn.addEventListener("click", downloadTxt);
    csvBtn.addEventListener("click", downloadCsv);

    torchBtn.addEventListener("click", async () => {
      if (!scanning || !qr || !hasTorch) return;
      await setTorch(qr, !torchOn);
    });

    // Zmiana trybu – wymagamy restartu (żeby zmienić formats/qrbox stabilnie)
    modeSelect.addEventListener("change", () => {
      if (scanning) {
        alert("Zmień tryb po kliknięciu Stop (tryb wpływa na formaty i ramkę skanowania).");
        modeSelect.value = "auto";
      }
    });

    window.addEventListener("pagehide", () => { try { stopScanning(false); } catch {} });
    document.addEventListener("visibilitychange", () => {
      if (document.hidden) { try { stopScanning(false); } catch {} }
    });

    load();
    renderList();
    setStatus("nie skanuje (wczytano z pamięci)");
  </script>
</body>

</html>
